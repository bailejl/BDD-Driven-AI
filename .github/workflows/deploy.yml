name: Deploy to Main

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production

env:
  NODE_VERSION: '24'

jobs:
  post-merge-validation:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout main branch
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: 'first-bank-of-change/package-lock.json'
        
    - name: Install dependencies
      working-directory: ./first-bank-of-change
      run: npm ci
      
    - name: Run comprehensive test suite
      working-directory: ./first-bank-of-change
      run: |
        echo "üß™ Running unit tests..."
        npm run test
        
        echo "üîç Running linting..."
        npm run lint
        
        echo "üèóÔ∏è Running build..."
        npm run build
        
    - name: Security audit on main
      working-directory: ./first-bank-of-change
      run: |
        echo "üîí Running security audit..."
        npm audit --audit-level=moderate
        
    - name: Clean up upgrade artifacts
      run: |
        # Remove any progress files that may have been merged
        find . -name "PROGRESS_upgrade-*.md" -type f -delete || true
        
        # Check if any cleanup is needed
        if [ -n "$(git status --porcelain)" ]; then
          echo "üßπ Cleaning up upgrade artifacts..."
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add .
          git commit -m "Clean up upgrade artifacts after merge" || true
          git push || true
        fi

  e2e-smoke-tests:
    runs-on: ubuntu-latest
    needs: post-merge-validation
    
    services:
      selenium:
        image: selenium/standalone-chrome:latest
        ports:
          - 4444:4444
          - 7900:7900
        options: --shm-size=2gb
    
    steps:
    - name: Checkout main branch
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: 'first-bank-of-change/package-lock.json'
        
    - name: Install dependencies
      working-directory: ./first-bank-of-change
      run: npm ci
      
    - name: Wait for Selenium
      run: |
        timeout 60s bash -c 'until curl -f http://localhost:4444/wd/hub/status; do sleep 2; done'
        
    - name: Run E2E smoke tests
      working-directory: ./first-bank-of-change
      run: npm run e2e-headless
      env:
        SELENIUM_HOST: localhost
        
    - name: Upload E2E artifacts on failure
      if: failure()
      uses: actions/upload-artifact@v4
      with:
        name: main-e2e-failure-artifacts
        path: |
          first-bank-of-change/.tmp/
          first-bank-of-change/allure-results/
        retention-days: 14

  build-and-package:
    runs-on: ubuntu-latest
    needs: [post-merge-validation, e2e-smoke-tests]
    
    steps:
    - name: Checkout main branch
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: 'first-bank-of-change/package-lock.json'
        
    - name: Install dependencies
      working-directory: ./first-bank-of-change
      run: npm ci
      
    - name: Build production assets
      working-directory: ./first-bank-of-change
      run: npm run build
      
    - name: Create build artifact
      uses: actions/upload-artifact@v4
      with:
        name: production-build
        path: first-bank-of-change/dist/
        retention-days: 30
        
    - name: Create deployment package
      run: |
        # Create a deployment package with necessary files
        mkdir -p deployment-package
        
        # Copy build artifacts
        cp -r first-bank-of-change/dist/ deployment-package/
        
        # Copy deployment configuration
        cp first-bank-of-change/package.json deployment-package/
        cp first-bank-of-change/docker-compose.yaml deployment-package/
        cp first-bank-of-change/npm.Dockerfile deployment-package/
        
        # Create deployment archive
        tar -czf deployment-package.tar.gz deployment-package/
        
    - name: Upload deployment package
      uses: actions/upload-artifact@v4
      with:
        name: deployment-package
        path: deployment-package.tar.gz
        retention-days: 90

  staging-deployment:
    runs-on: ubuntu-latest
    needs: build-and-package
    if: github.ref == 'refs/heads/main' || github.event.inputs.environment == 'staging'
    environment: staging
    
    steps:
    - name: Download deployment package
      uses: actions/download-artifact@v4
      with:
        name: deployment-package
        
    - name: Extract deployment package
      run: tar -xzf deployment-package.tar.gz
      
    - name: Deploy to staging
      run: |
        echo "üöÄ Deploying to staging environment..."
        echo "Build timestamp: $(date)"
        echo "Commit SHA: ${{ github.sha }}"
        
        # In a real deployment, this would:
        # - Deploy to staging server
        # - Update staging database
        # - Run staging smoke tests
        # - Update deployment status
        
        echo "‚úÖ Staging deployment completed"
        
    - name: Run staging smoke tests
      run: |
        echo "üß™ Running staging smoke tests..."
        # In a real deployment, this would run tests against staging
        echo "‚úÖ Staging smoke tests passed"
        
    - name: Update deployment status
      uses: actions/github-script@v7
      with:
        script: |
          const { data: commit } = await github.rest.repos.getCommit({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: context.sha
          });
          
          const deploymentMessage = `
          üöÄ **Staging Deployment Successful**
          
          **Commit:** ${context.sha.substr(0, 7)} - ${commit.commit.message.split('\n')[0]}
          **Environment:** Staging
          **Deployed:** ${new Date().toISOString()}
          
          ‚úÖ All validation checks passed
          ‚úÖ E2E smoke tests passed
          ‚úÖ Application deployed successfully
          `;
          
          // Create a deployment status (this would be customized for your deployment system)
          console.log(deploymentMessage);

  production-deployment:
    runs-on: ubuntu-latest
    needs: [build-and-package, staging-deployment]
    if: github.event.inputs.environment == 'production'
    environment: production
    
    steps:
    - name: Download deployment package
      uses: actions/download-artifact@v4
      with:
        name: deployment-package
        
    - name: Extract deployment package
      run: tar -xzf deployment-package.tar.gz
      
    - name: Deploy to production
      run: |
        echo "üöÄ Deploying to production environment..."
        echo "Build timestamp: $(date)"
        echo "Commit SHA: ${{ github.sha }}"
        
        # In a real deployment, this would:
        # - Deploy to production servers
        # - Update production database (with migrations)
        # - Perform blue-green deployment
        # - Update load balancer configuration
        # - Run production smoke tests
        
        echo "‚úÖ Production deployment completed"
        
    - name: Run production smoke tests
      run: |
        echo "üß™ Running production smoke tests..."
        # In a real deployment, this would run critical tests against production
        echo "‚úÖ Production smoke tests passed"
        
    - name: Create GitHub release
      if: success()
      uses: actions/github-script@v7
      with:
        script: |
          const { data: commit } = await github.rest.repos.getCommit({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: context.sha
          });
          
          const releaseTag = `v${new Date().toISOString().slice(0, 10).replace(/-/g, '')}-${context.sha.substr(0, 7)}`;
          
          await github.rest.repos.createRelease({
            owner: context.repo.owner,
            repo: context.repo.repo,
            tag_name: releaseTag,
            name: `Production Release ${releaseTag}`,
            body: `
            ## üöÄ Production Deployment
            
            **Commit:** ${context.sha.substr(0, 7)} - ${commit.commit.message.split('\n')[0]}
            **Deployed:** ${new Date().toISOString()}
            
            ### ‚úÖ Validation Checklist
            - [x] Unit tests passed
            - [x] E2E tests passed  
            - [x] Security audit passed
            - [x] Staging deployment successful
            - [x] Production smoke tests passed
            
            ### üìã Deployment Notes
            - All quality gates passed
            - No critical vulnerabilities detected
            - Backward compatibility maintained
            `,
            draft: false,
            prerelease: false
          });

  upgrade-coordination:
    runs-on: ubuntu-latest
    needs: post-merge-validation
    if: contains(github.event.head_commit.message, 'upgrade/')
    
    steps:
    - name: Update upgrade tracking
      uses: actions/github-script@v7
      with:
        script: |
          const commitMessage = context.payload.head_commit.message;
          const upgradeMatch = commitMessage.match(/upgrade\/([a-z0-9-]+)/);
          
          if (upgradeMatch) {
            const upgradeType = upgradeMatch[1];
            
            // Comment on any open upgrade PRs about the merge
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              head: `${context.repo.owner}:upgrade/`
            });
            
            for (const pr of prs) {
              if (pr.head.ref.includes('upgrade/')) {
                const comment = `
                ## üîÑ Upgrade Coordination Update
                
                **Merged upgrade:** \`${upgradeType}\`
                
                This may affect your upgrade branch. Please:
                1. Rebase your branch on latest main
                2. Resolve any conflicts  
                3. Re-run validation tests
                
                See PARALLEL_WORKFLOW.md for coordination guidelines.
                `;
                
                await github.rest.issues.createComment({
                  issue_number: pr.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: comment
                });
              }
            }
          }